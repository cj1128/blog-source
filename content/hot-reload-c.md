---
title: 热重载 C
date: 2021-04-25T21:27:10+08:00
draft: true
---

热重载是一个非常好用的功能，可以在不重启的情况下更新应用，从而大大提高开发效率。

前端的 Wepback，后端的 Ruby/Python/Elixir，移动端的 Flutter 都有热重载，属于用过以后就回不去的 Killer Feature。

在我之前的印象中，一直认为只有脚本语言才可以支持热重载，因为有虚拟机，热重载的实现变得非常简单，让虚拟机重新运行代码即可。

直到有一天，[Casey](https://twitter.com/cmuratori) 用非常少的代码演示了怎样热重载 C，我才恍然大悟，编译语言一样可以热重载。

<!--more-->

## Showtime

我们先来看看，最后的效果如何。

<video controls>
  <source src="http://asset.cjting.cn/FrUTcH3rMiOk_2TaWamOutbVvWgs.mp4" type="video/mp4">
</video>

这里我用 SDL 打开一个窗口并进行绘制，通过热重载，我们可以在程序不重启的情况下任意修改我们的绘图代码并实时查看效果。

相比于传统的修改、编译、运行，热重载有两个核心优势，特别是在游戏开发中。

第一是提高效率，游戏开发过程中经常需要调试一些参数，如果每次调整都需要重新编译重新运行的话，很繁琐也很耽误时间。

第二是可以保持状态，比如我现在要调整某个怪物的攻击行为，但是这个怪物在第 10 个房间，通过热重载，我可以直接重载怪物行为的相关代码，但是如果编译重新运行，每次我都需要先跑到第 10 个房间。

那么目前流行的游戏引擎是怎么解决这个问题的？一般来说是通过嵌入一个虚拟机，比如 JS 或者 Lua。

游戏引擎的核心部分都是 C/C++，通过引入虚拟机将游戏的逻辑通过脚本编写从而实现热重载。

那么热重载 C 是怎样实现的？为什么一个编译语言可以热重载？

这里的核心是 **动态链接库**。

## Dynamic Library

动态链接库大家肯定都不陌生，Windows 上随处可见的 `.DLL` 就是动态链接库。

在 Mac 和 Linux 上，动态链接库的后缀分别是 `.dylib` 和 `.so`。

既然有动态链接库，那么自然的也有静态链接库，他们对应的就是两种链接方式：动态链接和静态链接。

两种链接的区别简单来说如下：

静态链接在链接时会将库拷贝进可执行程序中，可执行程序不再依赖任何外部文件就可以运行。

而动态链接会在可执行程序中写入库的相关信息，比如库的路径，当可执行程序运行时，再去路径上加载库。

也就是说，动态链接的程序是对外部有依赖的，如果相关依赖不存在，程序也就无法执行。

总结一下

- 静态链接无依赖，自包含，体积大
- 动态链接有依赖，运行时需要加载外部文件，体积小

考虑到目前大部分情况下文件大小已经是一个无关紧要的事情，那么静态链接似乎是一个更好的选择，动态链接还有使用的必要吗？

### Why

我们先来看最开始为什么发明动态链接，只是为了节省文件体积吗？

### How

动态链接的工作原理?

## Final Code

我们将代码拆分为两部分，Main + Render，分别编译得到 `main.out` 可执行程序 和 `render.dylib` 动态链接库。

{{% tip %}}
在 Mac 上，动态链接库的后缀为 `.dylib`，Linux 上是 `.so`，Windows 是非常著名的 `.dll`。
{{% /tip %}}

在 Main 中，我们运行时打开动态链接库，获取其中的函数并运行，这样，一旦 `render.dylib` 更新，Main 中立刻就可以获取到最新的代码。

用伪代码来表示大概是这样

```python
while True:
  dylib = openDLL("render.dylib")
  render = getFunc(dylib, "Render")
  redner()
  closeDLL(dylib)
```
